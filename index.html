<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>~/system/dark_side</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">

    <style>
        /* --- [ SYSTEM CONFIG ] --- */
        :root {
            --bg-color: #000000;
            --text-main: #e0e0e0;
            --text-dim: #444444;
            --panel-bg: #000000;
            
            /* -- ALGERIAN PALETTE -- */
            --alg-green: #006233; 
            --alg-red: #D21034;   
            
            /* -- SEMANTICS -- */
            --border-color: var(--alg-green);
            --keyword: var(--alg-green);
            --function: var(--alg-red);
            --string: #ffffff;
            --comment: var(--text-dim);
            --cursor: var(--alg-red);
            
            /* -- BINARY RAIN -- */
            --binary-dim: #00331a; 
            --binary-bright: #00ff55; 
        }

        body.light-mode {
            --bg-color: #f4f4f4;
            --text-main: #111111;
            --text-dim: #888888;
            --panel-bg: #ffffff;
            --string: #444444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            height: 100vh;
            display: flex;
            overflow: hidden;
            text-transform: lowercase;
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- LAYOUT --- */
        .sidebar-left, .sidebar-right {
            width: 260px;
            border-right: 1px solid var(--border-color); /* Adjusted for initial hidden state */
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: var(--panel-bg);
            flex-shrink: 0;
            z-index: 10;
            transition: transform 0.5s ease-out; /* Slide in effect */
            transform: translateX(-100%); /* Start hidden left */
        }
        .sidebar-right {
            border-left: 1px solid var(--border-color);
            border-right: none; /* Only one border per sidebar */
            transform: translateX(100%); /* Start hidden right */
        }

        body.loaded .sidebar-left { transform: translateX(0); }
        body.loaded .sidebar-right { transform: translateX(0); }


        .main-content {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-color);
            overflow: hidden; 
        }

        #terminal-output {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 40px;
            scrollbar-width: none; 
            box-sizing: border-box; /* Padding included in width/height */
            display: flex; /* For centering prism */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #terminal-output::-webkit-scrollbar { display: none; }

        /* --- UI ELEMENTS --- */
        button {
            color: inherit;
            text-decoration: none;
            background: none;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: inherit;
            display: block;
            margin-bottom: 8px;
            text-align: left;
            transition: color 0.2s;
            width: 100%;
        }
        button:hover { color: var(--string); }
        button:hover::before { content: "["; color: var(--alg-red); margin-right: 5px; }
        button:hover::after { content: "]"; color: var(--alg-red); margin-left: 5px; }

        /* --- PRISM ASCII STYLES --- */
        .intro-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            cursor: pointer;
            box-sizing: border-box;
            max-width: 900px; /* Limita el ancho en pantallas muy grandes */
        }
        
        .prism-art {
            font-size: 14px; 
            white-space: pre; 
            line-height: 12px; /* Más compacto para líneas mas finas */
            margin-bottom: 30px;
            font-weight: bold;
            text-align: center;
            color: var(--text-main);
            transform: scale(1.1); /* Un poco más grande */
            transition: transform 0.2s;
            min-width: 300px; /* Asegura que no sea demasiado pequeño */
        }

        /* HAZ DE LUZ DE ENTRADA (Blanco Puro) */
        .beam-in { 
            color: #ffffff; 
            text-shadow: 0 0 5px #ffffff, 0 0 10px #ffffff; 
            font-weight: 900;
        }

        /* HAZ DE LUZ DE SALIDA (Arcoiris Argelia) */
        .beam-out { 
            animation: colorCycle 3s infinite alternate; /* Más suave y alternado */
            font-weight: 900;
            text-shadow: 0 0 3px currentColor, 0 0 6px currentColor;
        }

        /* BORDE DEL TRIÁNGULO */
        .tri-border {
            color: var(--text-dim);
            font-weight: bold;
        }

        /* INTERIOR DEL TRIÁNGULO (Ruido de datos) */
        .tri-noise {
            color: var(--text-dim);
            opacity: 0.3;
        }

        @keyframes colorCycle {
            0% { color: var(--alg-green); }
            50% { color: var(--alg-red); }
            100% { color: var(--alg-green); }
        }

        .click-prompt {
            animation: blink 1.5s infinite; /* Parpadeo más estándar */
            color: var(--text-dim);
            font-size: 12px;
            margin-top: 40px;
            opacity: 0; /* Oculto hasta que el prisma se escribe */
            transition: opacity 0.5s;
        }

        .click-prompt.active { opacity: 1; } /* Se activa al terminar la escritura */

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        .fade-in { animation: fadeIn 0.5s ease-in forwards; opacity: 0; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Contenido del módulo cuando se muestra */
        .module-content {
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            text-align: left;
            padding-top: 50px; /* Ajuste si el main-content ya no tiene padding */
        }

        .kw { color: var(--keyword); font-weight: 600; }
        .fn { color: var(--function); }
        .str { color: var(--string); }
        .com { color: var(--comment); font-style: italic;}
        pre { padding: 20px 0; overflow-x: auto; font-size: 13px; }
        
        .cursor {
            display: inline-block;
            width: 8px;
            height: 1.2em;
            background-color: var(--cursor);
            vertical-align: bottom;
        }
        .cursor.blinking { animation: blink 1s step-end infinite; }

        @media (max-width: 1000px) {
            body { flex-direction: column; height: auto; overflow: auto; }
            .sidebar-left, .sidebar-right { 
                width: 100%; height: auto; border: none; border-bottom: 1px solid var(--border-color); 
                transform: translateX(0) !important; /* Siempre visibles en móvil */
            }
            .main-content { padding: 0; }
            #terminal-output { padding: 20px; min-height: 500px; height: auto; } 
            .intro-container { height: 400px; }
            .prism-art { font-size: 10px; transform: scale(1); }
            #binary-grid { display: none; }
        }
    </style>
</head>
<body>

    <aside class="sidebar-left"></aside>
    <main class="main-content">
        <div id="terminal-output"></div>
    </main>
    <aside class="sidebar-right"></aside>

    <script>
        // --- 1. MÓDULOS DE CONTENIDO ---
        const modules = {
            about: `
                <section class="fade-in module-content">
                    <span class="com">// bio loaded successfully</span><br><br>
                    <p><span class="kw">>></span> cat profile.txt</p>
                    <br>
                    <p>systems engineering student.</p>
                    <p>i see the world through a prism: breaking down complex problems into fundamental components.</p>
                    <br>
                    <p>specializing in robust backend systems, data flow architectures, and critical statistical analysis.</p>
                </section>
            `,
            stack: `
                <section class="fade-in module-content">
                    <span class="com">// tech stack analysis</span><br><br>
                    <p><span class="kw">>></span> cat skills.json</p>
                    <pre>
{
  <span class="str">"core"</span>: [<span class="str">"java"</span>, <span class="str">"python"</span>, <span class="str">"sql"</span>],
  <span class="str">"data_integrity"</span>: <span class="str">"acid compliant systems"</span>,
  <span class="str">"workflow"</span>: <span class="str">"docker / git / ci/cd"</span>
}</pre>
                </section>
            `,
            projects: `
                <section class="fade-in module-content">
                    <span class="com">// retrieving repositories...</span><br><br>
                    <p><span class="kw">>></span> ls -la ./projects/</p>
                    <br>
                    <div style="margin-bottom: 20px;">
                        <span class="kw">const</span> <span class="fn">refraction_engine</span> = {<br>
                        &nbsp;&nbsp;<span class="str">"type"</span>: <span class="str">"realtime_data_pipeline"</span>,<br>
                        &nbsp;&nbsp;<span class="str">"status"</span>: <span class="str">"deployed"</span><br>
                        }; <a href="#">[ view_source ]</a>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <span class="kw">const</span> <span class="fn">spectrum_analyzer</span> = {<br>
                        &nbsp;&nbsp;<span class="str">"type"</span>: <span class="str">"python_statistical_model"</span>,<br>
                        &nbsp;&nbsp;<span class="str">"desc"</span>: <span class="str">"complex distribution mapping"</span><br>
                        }; <a href="#">[ view_source ]</a>
                    </div>
                </section>
            `,
            contact: `
                <section class="fade-in module-content">
                    <span class="com">// opening secure channel...</span><br><br>
                    <p><span class="kw">>></span> ./connect.sh</p>
                    <br>
                    <ul>
                        <li><span class="kw">email:</span> <a href="mailto:you@mail.com">you@mail.com</a></li>
                        <li><span class="kw">github:</span> <a href="#">github.com/user</a></li>
                    </ul>
                </section>
            `
        };

        const outputDiv = document.getElementById('terminal-output');
        let prismTypewriterInterval; // Para la animación de escritura
        let prismGlitchInterval;     // Para la animación de glitch

        // --- 2. MAPA DEL PRISMA DE ALTA FIDELIDAD ---
        // ' ' = Vacío
        // '_' = Borde superior/inferior
        // '/' = Borde diagonal izquierdo
        // '\' = Borde diagonal derecho
        // '|' = Borde vertical (para la base si es necesario)
        // 'I' = Interior (Noise)
        // 'L' = Haz de Entrada
        // 'R' = Haz de Salida
        
        const prismMap = [
            "                                _ _                                    ",
            "                              _/   \\_                                  ",
            "                            _/       \\_                                ",
            "                          _/           \\_                              ",
            "                        _/               \\_                            ",
            "                      _/                   \\_                          ",
            "                    _/                       \\_                        ",
            "                  _/                           \\_                      ",
            "                _/       I I I I I I I         /                       ",
            "              _/         I I I I I I I       /                         ",
            "            _/           I I I I I I I     /                           ",
            "          _/             I I I I I I I   /                             ",
            "        _/               I I I I I I I /                               ",
            "      _/                 I I I I I I I/                                ",
            "    _/                   I I I I I I I\\                               ",
            "   | LLLLLLLLLLLLLLL     I I I I I I I \\ RRRRRRRRRRRRRRRRRRR           ",
            "   |                 _ _ _ _ _ _ _ _ _ _\\_                            ",
            "   |               _/                     \\_                           ",
            "   |_ _ _ _ _ _ _ _/                         \\_ _ _ _ _ _ _ _ _ _ _ _ _ "
        ];
        
        const noiseChars = ['.', ':', '~', '^', '*']; // Caracteres para el ruido interno

        // Función para renderizar el prisma completo sin animación
        function renderPrismStatic() {
            let html = '';
            for (let r = 0; r < prismMap.length; r++) {
                let line = '';
                for (let c = 0; c < prismMap[r].length; c++) {
                    const charType = prismMap[r][c];
                    if (charType === ' ') line += ' ';
                    else if (charType === '_') line += `<span class="tri-border">_</span>`;
                    else if (charType === '/') line += `<span class="tri-border">/</span>`;
                    else if (charType === '\\') line += `<span class="tri-border">\\</span>`;
                    else if (charType === '|') line += `<span class="tri-border">|</span>`;
                    else if (charType === 'I') line += `<span class="tri-noise">${noiseChars[Math.floor(Math.random() * noiseChars.length)]}</span>`;
                    else if (charType === 'L') line += `<span class="beam-in">-</span>`;
                    else if (charType === 'R') line += `<span class="beam-out">=</span>`;
                }
                html += line + '\n';
            }
            return html;
        }

        let currentPrismHTML = ''; // Almacena el HTML del prisma conforme se escribe

        // Función para "escribir" el prisma carácter por carácter
        function typePrism() {
            outputDiv.innerHTML = `
                <div class="intro-container" onclick="loadModule('about')">
                    <div id="prism-target" class="prism-art"></div>
                    <div id="click-prompt" class="click-prompt"></div>
                </div>
            `;
            
            const target = document.getElementById('prism-target');
            const clickPrompt = document.getElementById('click-prompt');
            let charIndex = 0;
            currentPrismHTML = '';
            
            // Limpiamos intervalos previos
            clearInterval(prismTypewriterInterval);
            clearInterval(prismGlitchInterval);

            // Tipo de animación para escribir
            const typingSpeed = 5; // Velocidad de escritura (ms por caracter)

            prismTypewriterInterval = setInterval(() => {
                if (charIndex >= prismMap.join('\n').length) {
                    clearInterval(prismTypewriterInterval);
                    // Una vez escrito, activamos el glitch y el prompt
                    prismGlitchInterval = setInterval(animatePrismGlitch, 200); // Glitch un poco más rápido
                    clickPrompt.innerHTML = '[ click_prism_to_enter ]';
                    clickPrompt.classList.add('active'); // Mostrar el prompt con fade-in
                    return;
                }

                const fullPrismString = prismMap.join('\n');
                const charToAdd = fullPrismString[charIndex];
                
                // Determinamos la clase para el carácter
                let charHTML = '';
                if (charToAdd === ' ') charHTML = ' ';
                else if (charToAdd === '_') charHTML = `<span class="tri-border">_</span>`;
                else if (charToAdd === '/') charHTML = `<span class="tri-border">/</span>`;
                else if (charToAdd === '\\') charHTML = `<span class="tri-border">\\</span>`;
                else if (charToAdd === '|') charHTML = `<span class="tri-border">|</span>`;
                else if (charToAdd === 'I') charHTML = `<span class="tri-noise">${noiseChars[Math.floor(Math.random() * noiseChars.length)]}</span>`;
                else if (charToAdd === 'L') charHTML = `<span class="beam-in">-</span>`;
                else if (charToAdd === 'R') charHTML = `<span class="beam-out">=</span>`;
                else if (charToAdd === '\n') charHTML = '\n'; // Nuevas líneas

                currentPrismHTML += charHTML;
                target.innerHTML = currentPrismHTML;
                
                charIndex++;
            }, typingSpeed);
        }

        // Animación de glitch (solo el interior)
        function animatePrismGlitch() {
            const target = document.getElementById('prism-target');
            if(!target || !currentPrismHTML) {
                clearInterval(prismGlitchInterval); // Detener si no existe
                return;
            }

            let newHTML = '';
            let charPos = 0;
            for(let row of prismMap) {
                for(let charType of row) {
                    if(charType === 'I') {
                        // Reemplaza un carácter de ruido existente
                        const randChar = noiseChars[Math.floor(Math.random() * noiseChars.length)];
                        newHTML += `<span class="tri-noise">${randChar}</span>`;
                        // Avanza el índice para el HTML original
                        charPos += currentPrismHTML.substring(charPos).indexOf('</span>') + 7;
                    } else {
                        // Copia el HTML original hasta el siguiente ruido o fin de elemento
                        const nextNoiseIndex = currentPrismHTML.substring(charPos).indexOf('<span class="tri-noise">');
                        if(nextNoiseIndex !== -1) {
                            newHTML += currentPrismHTML.substring(charPos, charPos + nextNoiseIndex);
                            charPos += nextNoiseIndex;
                        } else {
                            newHTML += currentPrismHTML.substring(charPos);
                            charPos = currentPrismHTML.length;
                        }
                    }
                }
                newHTML += '\n'; // Mantener nuevas líneas
            }
            target.innerHTML = newHTML;
        }


        // --- 3. FUNCIONES GENERALES ---
        function loadModule(moduleName) {
            clearInterval(prismTypewriterInterval); // Detener escritura
            clearInterval(prismGlitchInterval);     // Detener glitch
            outputDiv.innerHTML = '';
            
            // Ocultar sidebars antes de mostrar contenido
            document.body.classList.remove('loaded');

            // Cargar contenido en el main
            const moduleContentContainer = document.createElement('div');
            moduleContentContainer.className = 'module-content';
            moduleContentContainer.innerHTML = modules[moduleName];
            outputDiv.appendChild(moduleContentContainer);

            // Mostrar sidebars con delay
            setTimeout(() => {
                document.body.classList.add('loaded');
            }, 100); // Pequeño delay para la transición
        }

        // Inicializar Sidebars
        function initSidebars() {
            document.querySelector('.sidebar-left').innerHTML = `
                <div>
                    <div id="ascii-anim" style="color: var(--alg-red); font-weight: bold; margin-bottom: 30px; white-space: pre; line-height: 12px;"></div>
                    <div style="margin-bottom: 30px;">
                        <span class="kw">sys_status:</span> online<br>
                        <span class="kw">user:</span> guest
                    </div>
                    <nav>
                        <span class="com">// modules</span><br>
                        <button onclick="loadModule('about')">01. about_me</button>
                        <button onclick="loadModule('stack')">02. tech_stack</button>
                        <button onclick="loadModule('projects')">03. projects</button>
                        <button onclick="loadModule('contact')">04. contact</button>
                        <br>
                        <button onclick="typePrism()">[ return_home ]</button>
                    </nav>
                </div>
                <div style="font-size: 12px; color: var(--text-dim);">
                    <button onclick="toggleTheme()" style="margin-bottom: 20px;">[ light_mode ]</button>
                    <span id="clock">--:--:--</span>
                </div>
            `;
            document.querySelector('.sidebar-right').innerHTML = `
                <div style="margin-bottom: 10px; color: var(--alg-green);">
                    <span class="com">// data_stream</span>
                </div>
                <div id="binary-grid" style="font-size: 12px; line-height: 14px; color: var(--alg-green); opacity: 0.7; word-break: break-all;"></div>
            `;
        }

        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const btn = document.querySelector("button[onclick='toggleTheme()']");
            btn.innerText = document.body.classList.contains('light-mode') ? "[ dark_mode ]" : "[ light_mode ]";
        }

        // Sidebar Anims
        const radarFrames = ["  .  \n ... \n.....", "  |  \n -+- \n  |  ", "  /  \n  +  \n  /  ", "  -  \n -+- \n  -  ", "  \\  \n  +  \n  \\  "];
        let frameIndex = 0;
        setInterval(() => {
            const el = document.getElementById('ascii-anim');
            if(el) el.innerText = radarFrames[frameIndex];
            frameIndex = (frameIndex + 1) % radarFrames.length;
        }, 200);

        const binaryGrid = document.getElementById('binary-grid');
        let binaryHTML = '';
        for(let r=0; r<30; r++) {
            binaryHTML += '<div>';
            for(let c=0; c<12; c++) {
                binaryHTML += `<span id="bit-${r}-${c}">0</span> `;
            }
            binaryHTML += '</div>';
        }
        // Solo inyectar si el elemento existe (estará vacío al inicio)
        if(binaryGrid) binaryGrid.innerHTML = binaryHTML; 

        setInterval(() => {
            // Solo animar si los sidebars están visibles (es decir, body.loaded)
            if(!document.body.classList.contains('loaded')) return;

            for(let k=0; k<10; k++) {
                const r = Math.floor(Math.random() * 30);
                const c = Math.floor(Math.random() * 12);
                const bit = document.getElementById(`bit-${r}-${c}`);
                if(bit) {
                    bit.innerText = Math.random() > 0.5 ? '1' : '0';
                    bit.style.color = Math.random() > 0.9 ? 'var(--binary-bright)' : 'var(--binary-dim)';
                }
            }
        }, 100);

        setInterval(() => {
            const clock = document.getElementById('clock');
            // Solo actualizar si el reloj está visible (sidebars cargados)
            if(clock && document.body.classList.contains('loaded')) {
                clock.innerText = new Date().toLocaleTimeString('en-US', {hour12:false});
            }
        }, 1000);

        // --- INICIO DE LA APLICACIÓN ---
        window.onload = () => {
            initSidebars(); // Inicializamos el contenido de los sidebars
            typePrism();    // Mostramos la animación de escritura del prisma
        };
    </script>
</body>
</html>